{\rtf1\ansi\ansicpg936\cocoartf2758
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\li640\fi640\sl480\qj\partightenfactor0

\f0\fs32 \cf2 \expnd0\expndtw0\kerning0
#![no_std]
\f1\fs28 \

\f0\fs32 #![no_main]
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 extern crate alloc;
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 #[macro_use]
\f1\fs28 \

\f0\fs32 extern crate user_lib;
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 const LF: u8 = 0x0au8;
\f1\fs28 \

\f0\fs32 const CR: u8 = 0x0du8;
\f1\fs28 \

\f0\fs32 const DL: u8 = 0x7fu8;
\f1\fs28 \

\f0\fs32 const BS: u8 = 0x08u8;
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 use alloc::string::String;
\f1\fs28 \

\f0\fs32 use user_lib::\{fork, exec, waitpid\};
\f1\fs28 \

\f0\fs32 use user_lib::console::getchar;
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 #[no_mangle]
\f1\fs28 \

\f0\fs32 pub fn main() -> i32 \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 println!("Rust user shell");
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 let mut line: String = String::new();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 print!(">> ");
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 loop \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 let c = getchar();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 match c \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 LF | CR => \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 println!("");
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if !line.is_empty() \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 line.push('\\0');
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 let pid = fork();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if pid == 0 \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // child process
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if exec(line.as_str()) == -1 \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 println!("Error when executing!");
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return -4;
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 unreachable!();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \} else \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 let mut exit_code: i32 = 0;
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 let exit_pid = waitpid(pid as usize, &mut exit_code);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 assert_eq!(pid, exit_pid);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 println!("Shell: Process \{\} exited with code \{\}", pid, exit_code);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 line.clear();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 print!(">> ");
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 BS | DL => \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if !line.is_empty() \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 print!("\{\}", BS as char);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 print!(" ");
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 print!("\{\}", BS as char);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 line.pop();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 _ => \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 print!("\{\}", c as char);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 line.push(c as char);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \
}