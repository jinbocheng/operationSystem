{\rtf1\ansi\ansicpg936\cocoartf2758
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\li640\fi640\sl480\qj\partightenfactor0

\f0\fs32 \cf2 \expnd0\expndtw0\kerning0
use super::\{TaskContext, TaskControlBlock\};
\f1\fs28 \

\f0\fs32 use alloc::sync::Arc;
\f1\fs28 \

\f0\fs32 use lazy_static::*;
\f1\fs28 \

\f0\fs32 use super::\{fetch_task, TaskStatus\};
\f1\fs28 \

\f0\fs32 use super::__switch;
\f1\fs28 \

\f0\fs32 use crate::trap::TrapContext;
\f1\fs28 \

\f0\fs32 use crate::sync::UPSafeCell;
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 pub struct Processor \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 current: Option<Arc<TaskControlBlock>>,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 idle_task_cx: TaskContext,
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 impl Processor \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 pub fn new() -> Self \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 Self \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 current: None,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 idle_task_cx: TaskContext::zero_init(),
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 fn get_idle_task_cx_ptr(&mut self) -> *mut TaskContext \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 &mut self.idle_task_cx as *mut _
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 pub fn take_current(&mut self) -> Option<Arc<TaskControlBlock>> \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 self.current.take()
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 pub fn current(&self) -> Option<Arc<TaskControlBlock>> \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 self.current.as_ref().map(|task| Arc::clone(task))
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 lazy_static! \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 pub static ref PROCESSOR: UPSafeCell<Processor> = unsafe \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 UPSafeCell::new(Processor::new())
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \};
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 pub fn run_tasks() \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 loop \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 let mut processor = PROCESSOR.exclusive_access();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if let Some(task) = fetch_task() \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 let idle_task_cx_ptr = processor.get_idle_task_cx_ptr();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // access coming task TCB exclusively
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 let mut task_inner = task.inner_exclusive_access();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 let next_task_cx_ptr = &task_inner.task_cx as *const TaskContext;
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 task_inner.task_status = TaskStatus::Running;
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 drop(task_inner);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // release coming task TCB manually
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 processor.current = Some(task);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 // release processor manually
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 drop(processor);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 unsafe \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 __switch(
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 idle_task_cx_ptr,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 next_task_cx_ptr,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 );
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 pub fn take_current_task() -> Option<Arc<TaskControlBlock>> \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 PROCESSOR.exclusive_access().take_current()
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 pub fn current_task() -> Option<Arc<TaskControlBlock>> \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 PROCESSOR.exclusive_access().current()
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 pub fn current_user_token() -> usize \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 let task = current_task().unwrap();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 let token = task.inner_exclusive_access().get_user_token();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 token
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 pub fn current_trap_cx() -> &'static mut TrapContext \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 current_task().unwrap().inner_exclusive_access().get_trap_cx()
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 pub fn schedule(switched_task_cx_ptr: *mut TaskContext) \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 let mut processor = PROCESSOR.exclusive_access();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 let idle_task_cx_ptr = processor.get_idle_task_cx_ptr();
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 drop(processor);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 unsafe \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 __switch(
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 switched_task_cx_ptr,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 idle_task_cx_ptr,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 );
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \
}