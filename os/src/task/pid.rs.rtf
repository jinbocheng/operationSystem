{\rtf1\ansi\ansicpg936\cocoartf2758
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\li640\fi640\sl480\qj\partightenfactor0

\f0\fs32 \cf2 \expnd0\expndtw0\kerning0
pub struct PidHandle(pub usize);
\f1\fs28 \
\

\f0\fs32 struct PidAllocator \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 current: usize,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 recycled: Vec<usize>,
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 impl PidAllocator \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 pub fn new() -> Self \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 PidAllocator \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 current: 0,
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 recycled: Vec::new(),
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 pub fn alloc(&mut self) -> PidHandle \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if let Some(pid) = self.recycled.pop() \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 PidHandle(pid)
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \} else \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 self.current += 1;
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 PidHandle(self.current - 1)
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 pub fn dealloc(&mut self, pid: usize) \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 assert!(pid < self.current);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 assert!(
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 self.recycled.iter().find(|ppid| **ppid == pid).is_none(),
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 "pid \{\} has been deallocated!", pid
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 );
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 self.recycled.push(pid);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \

\f0\fs32 \'a0
\f1\fs28 \

\f0\fs32 lazy_static! \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 static ref PID_ALLOCATOR : UPSafeCell<PidAllocator> = unsafe \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 UPSafeCell::new(PidAllocator::new())
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \};
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \
\

\f0\fs32 pub fn pid_alloc() -> PidHandle \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 PID_ALLOCATOR.exclusive_access().alloc()
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \
\

\f0\fs32 impl Drop for PidHandle \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 fn drop(&mut self) \{
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 //println!("drop pid \{\}", self.0);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 PID_ALLOCATOR.exclusive_access().dealloc(self.0);
\f1\fs28 \

\f0\fs32 \'a0\'a0\'a0 \}
\f1\fs28 \

\f0\fs32 \}
\f1\fs28 \
}